package burp.util.vuln;

import java.util.*;

public class VulnerabilityPatternMatcher {
    
    private final List<VulnerabilityPattern> patterns;
    
    public VulnerabilityPatternMatcher() {
        this.patterns = new ArrayList<>();
        initializeDefaultPatterns();
    }
    
    private void initializeDefaultPatterns() {
        // SQL注入模式
        VulnerabilityPattern sqliPattern = new VulnerabilityPattern("sqli_basic", "SQL注入", "注入攻击");
        sqliPattern.setDescription("检测SQL注入漏洞特征");
        sqliPattern.setSeverity(4);
        sqliPattern.addCondition("param:value contains ' OR '");
        sqliPattern.addCondition("param:value contains --");
        sqliPattern.addCondition("param:value contains UNION");
        sqliPattern.addCondition("response:SQL syntax");
        sqliPattern.addCondition("response:mysql_fetch");
        sqliPattern.addSuggestion("使用参数化查询");
        sqliPattern.addSuggestion("过滤特殊字符");
        sqliPattern.addTestPayload("单引号测试", "'");
        sqliPattern.addTestPayload("OR测试", "' OR '1'='1");
        patterns.add(sqliPattern);
        
        // XSS模式
        VulnerabilityPattern xssPattern = new VulnerabilityPattern("xss_reflected", "反射型XSS", "XSS攻击");
        xssPattern.setDescription("检测反射型跨站脚本漏洞");
        xssPattern.setSeverity(4);
        xssPattern.addCondition("param:value contains <script");
        xssPattern.addCondition("param:value contains javascript:");
        xssPattern.addCondition("response:<script");
        xssPattern.addSuggestion("对用户输入进行HTML编码");
        xssPattern.addSuggestion("使用CSP头");
        xssPattern.addTestPayload("Script标签", "<script>alert(1)</script>");
        xssPattern.addTestPayload("事件处理器", "<img src=x onerror=alert(1)>");
        patterns.add(xssPattern);
        
        // 命令注入模式
        VulnerabilityPattern cmdiPattern = new VulnerabilityPattern("cmd_injection", "命令注入", "注入攻击");
        cmdiPattern.setDescription("检测操作系统命令注入漏洞");
        cmdiPattern.setSeverity(5);
        cmdiPattern.addCondition("param:value contains ; ");
        cmdiPattern.addCondition("param:value contains | ");
        cmdiPattern.addCondition("param:value contains `");
        cmdiPattern.addCondition("response:uid=");
        cmdiPattern.addCondition("response:total ");
        cmdiPattern.addSuggestion("避免直接执行用户输入");
        cmdiPattern.addSuggestion("使用白名单过滤");
        patterns.add(cmdiPattern);
        
        // 路径遍历模式
        VulnerabilityPattern lfiPattern = new VulnerabilityPattern("path_traversal", "路径遍历", "文件包含");
        lfiPattern.setDescription("检测本地文件包含/路径遍历漏洞");
        lfiPattern.setSeverity(4);
        lfiPattern.addCondition("param:value contains ../");
        lfiPattern.addCondition("param:value contains ..\\");
        lfiPattern.addCondition("param:value contains %2e%2e");
        lfiPattern.addCondition("response:root:");
        lfiPattern.addCondition("response:[boot loader]");
        lfiPattern.addSuggestion("验证用户输入路径");
        lfiPattern.addSuggestion("使用basename()处理文件名");
        patterns.add(lfiPattern);
        
        // SSRF模式
        VulnerabilityPattern ssrfPattern = new VulnerabilityPattern("ssrf", "服务端请求伪造", "SSRF");
        ssrfPattern.setDescription("检测服务端请求伪造漏洞");
        ssrfPattern.setSeverity(4);
        ssrfPattern.addCondition("param:value contains http://127.0.0.1");
        ssrfPattern.addCondition("param:value contains http://localhost");
        ssrfPattern.addCondition("param:value contains http://[::1]");
        ssrfPattern.addCondition("param:value contains file://");
        ssrfPattern.addSuggestion("白名单验证目标URL");
        ssrfPattern.addSuggestion("禁用危险协议");
        patterns.add(ssrfPattern);
        
        // XXE模式
        VulnerabilityPattern xxePattern = new VulnerabilityPattern("xxe", "XML外部实体注入", "XXE");
        xxePattern.setDescription("检测XML外部实体注入漏洞");
        xxePattern.setSeverity(4);
        xxePattern.addCondition("header:Content-Type contains xml");
        xxePattern.addCondition("request:<!DOCTYPE");
        xxePattern.addCondition("request:<!ENTITY");
        ssrfPattern.addSuggestion("禁用外部实体解析");
        ssrfPattern.addSuggestion("使用安全的XML解析器配置");
        patterns.add(xxePattern);
        
        // JWT模式
        VulnerabilityPattern jwtPattern = new VulnerabilityPattern("jwt_attacks", "JWT安全", "认证安全");
        jwtPattern.setDescription("检测JWT相关安全问题");
        jwtPattern.setSeverity(3);
        jwtPattern.addCondition("header:Authorization contains Bearer");
        jwtPattern.addCondition("response:eyJ");
        jwtPattern.addSuggestion("验证JWT签名");
        jwtPattern.addSuggestion("检查算法是否安全");
        jwtPattern.addSuggestion("验证令牌有效期");
        patterns.add(jwtPattern);
        
        // 敏感信息泄露模式
        VulnerabilityPattern infoLeakPattern = new VulnerabilityPattern("info_disclosure", "敏感信息泄露", "信息泄露");
        infoLeakPattern.setDescription("检测敏感信息泄露");
        infoLeakPattern.setSeverity(3);
        infoLeakPattern.addCondition("response:password");
        infoLeakPattern.addCondition("response:api_key");
        infoLeakPattern.addCondition("response:secret");
        infoLeakPattern.addCondition("response:stack trace");
        infoLeakPattern.addSuggestion("移除敏感信息");
        infoLeakPattern.addSuggestion("配置错误页面");
        patterns.add(infoLeakPattern);
        
        // 开放重定向模式
        VulnerabilityPattern redirectPattern = new VulnerabilityPattern("open_redirect", "开放重定向", "其他");
        redirectPattern.setDescription("检测开放重定向漏洞");
        redirectPattern.setSeverity(2);
        redirectPattern.addCondition("param:name contains redirect");
        redirectPattern.addCondition("param:name contains url");
        redirectPattern.addCondition("param:name contains next");
        redirectPattern.addCondition("param:value contains http");
        redirectPattern.addSuggestion("验证重定向URL白名单");
        redirectPattern.addSuggestion("使用相对路径重定向");
        patterns.add(redirectPattern);
        
        // CORS配置问题
        VulnerabilityPattern corsPattern = new VulnerabilityPattern("cors_misconfig", "CORS配置错误", "配置安全");
        corsPattern.setDescription("检测CORS配置问题");
        corsPattern.setSeverity(3);
        corsPattern.addCondition("header:Access-Control-Allow-Origin: *");
        corsPattern.addCondition("header:Access-Control-Allow-Credentials: true");
        corsPattern.addSuggestion("限制允许的源");
        corsPattern.addSuggestion("避免同时使用通配符和凭证");
        patterns.add(corsPattern);
    }
    
    public void addPattern(VulnerabilityPattern pattern) {
        if (pattern != null) {
            patterns.add(pattern);
        }
    }
    
    public void removePattern(String patternId) {
        patterns.removeIf(p -> p.getId().equals(patternId));
    }
    
    public VulnerabilityPattern getPattern(String patternId) {
        for (VulnerabilityPattern pattern : patterns) {
            if (pattern.getId().equals(patternId)) {
                return pattern;
            }
        }
        return null;
    }
    
    public List<VulnerabilityPattern> getAllPatterns() {
        return new ArrayList<>(patterns);
    }
    
    public List<VulnerabilityPattern> getPatternsByCategory(String category) {
        List<VulnerabilityPattern> result = new ArrayList<>();
        for (VulnerabilityPattern pattern : patterns) {
            if (category.equals(pattern.getCategory())) {
                result.add(pattern);
            }
        }
        return result;
    }
    
    public List<VulnerabilityPattern> getPatternsByMinSeverity(int minSeverity) {
        List<VulnerabilityPattern> result = new ArrayList<>();
        for (VulnerabilityPattern pattern : patterns) {
            if (pattern.getSeverity() >= minSeverity) {
                result.add(pattern);
            }
        }
        return result;
    }
    
    public List<MatchResult> match(VulnerabilityContext context) {
        List<MatchResult> results = new ArrayList<>();
        
        for (VulnerabilityPattern pattern : patterns) {
            if (pattern.matches(context)) {
                MatchResult result = new MatchResult(
                    pattern.getId(),
                    pattern.getName(),
                    pattern.getCategory(),
                    pattern.getSeverity(),
                    pattern.getSuggestions(),
                    System.currentTimeMillis()
                );
                results.add(result);
            }
        }
        
        results.sort((a, b) -> Integer.compare(b.getSeverity(), a.getSeverity()));
        
        return results;
    }
    
    public List<MatchResult> matchWithSeverity(VulnerabilityContext context, int minSeverity) {
        List<MatchResult> allResults = match(context);
        List<MatchResult> filtered = new ArrayList<>();
        
        for (MatchResult result : allResults) {
            if (result.getSeverity() >= minSeverity) {
                filtered.add(result);
            }
        }
        
        return filtered;
    }
    
    public List<String> getCategories() {
        Set<String> categories = new LinkedHashSet<>();
        for (VulnerabilityPattern pattern : patterns) {
            categories.add(pattern.getCategory());
        }
        return new ArrayList<>(categories);
    }
    
    public static class MatchResult {
        private final String patternId;
        private final String patternName;
        private final String category;
        private final int severity;
        private final List<String> suggestions;
        private final long timestamp;
        
        public MatchResult(String patternId, String patternName, String category, 
                         int severity, List<String> suggestions, long timestamp) {
            this.patternId = patternId;
            this.patternName = patternName;
            this.category = category;
            this.severity = severity;
            this.suggestions = suggestions != null ? new ArrayList<>(suggestions) : new ArrayList<>();
            this.timestamp = timestamp;
        }
        
        public String getPatternId() { return patternId; }
        public String getPatternName() { return patternName; }
        public String getCategory() { return category; }
        public int getSeverity() { return severity; }
        public List<String> getSuggestions() { return new ArrayList<>(suggestions); }
        public long getTimestamp() { return timestamp; }
        
        public String getSeverityLevel() {
            switch (severity) {
                case 5: return "严重";
                case 4: return "高危";
                case 3: return "中危";
                case 2: return "低危";
                case 1: return "信息";
                default: return "未知";
            }
        }
        
        @Override
        public String toString() {
            return String.format("MatchResult{id=%s, name=%s, severity=%s}",
                patternId, patternName, getSeverityLevel());
        }
    }
}
